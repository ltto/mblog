##JAVA内存模型规范
规范了JAVA虚拟机与计算机内存是如何协同工作的
规定了一个线程如何 / 何时可以看到其他线程修改过的共享变量的值,以及在必须时如何同步的访问共享变量

>heap 运行时分配运行大小 
>运行时分配存取速度比较慢
>栈的存取速度比heap快仅次于CPU寄存器 数据大小和生存期必须确定 主要存储基本类型对象 
>调用栈和本地变量放在stack(栈)

多线程访问heap中的变量 会在每个线程私有拷贝一个副本

stack 寄存器 高速缓存 主内存
heap  寄存器 高速缓存 主内存

私有工作内存优先存储于寄存去和高速缓存

`注*``*线程间的通讯必须经过主内存`

|原子性|备注|
|---|---|
|  synchronized | `monitorenter`和`monitorexit`指令,synchronized语义表示锁在同一时刻只能由一个线程进行获取 |
| `volatile`++操作无原子性 | 1/运算结果并不依赖于变量的当前值，或者能够确保只有一个线程修改变量的值；2/变量不需要与其他的状态变量共同参与不变约束 |

|有序性|备注|
|---|---|
|  synchronized |synchronized语义就要求线程在访问读写共享变量时只能“串行”执行 |
| volatile | volatile包含禁止指令重排序的语义，其具有有序性 |

|可见性|备注|
|---|---|
|  synchronized |当线程获取锁时会从主内存中获取共享变量的最新值，释放锁的时候会将共享变量同步到主内存中。 |
| volatile | 通过在指令中添加lock指令，以实现内存可见性 |

|总结|描述|重排序|
|---|---|---|
|synchronized|`原子性``有序性``可见性`|synchronized会有重排序`优化`|
|volatile|`有序性``可见性``操作不复杂的原子性`|volatile`不会`有重排序的优化|

1. “volatile” - 保证读写的都是主内存变量。
2. “synchronized” - 保证在块开始时。都同步主内存值到工作内存，而快结束时。将工作内存同步会主内存。
3. 
# synchronized, Lock, Atomic 性能对比
1. synchronized 不可中断锁, 适合竞争不激烈,可读性好
2. Lock可中断锁, 多样化同步, 竞争激烈时能维持常态
3. 竞争激烈时能维持常态 比Lock性能好 但是一次只能同步一个值
4. 通过代码比较(jdk8下) synchronized, Lock 性能相差无几