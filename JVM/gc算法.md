# JVM GC算法
## 判断存活的对象
+ 引用计数法 (弃用)
> 每个对象有一个引用计数属性，新增一个引用时计数加1，引用释放时计数减1，计数为0时可以回收。此方法简单，无法解决对象相互循环引用的问题。
+ 可达性分析 (GC ROOT)
> 从GC Roots开始向下搜索，搜索所走过的路径称为引用链。当一个对象到GC Roots没有任何引用链相连时，则证明此对象是不可用的。不可达对象。
## 适合GC ROOT的对象
+ `Alive`状态的线程
+ 当前调用栈中的对象
+ 方法区中的静态变量 class模板对象
+ SystemClassLoader加载的对象
+ 本地方法栈(JNI)中的对象
+ 正在使用中的锁对象

## 执行GC
+ Minor GC：新生代GC，指发生在新生代的垃圾收集动作，所有的Minor GC都会触发全世界的暂停（stop-the-world），停止应用程序的线程，不过这个过程非常短暂。
+ Major GC：老年代GC，指发生在老年代的GC。
+ Full GC: 新生 老年 方法区的GC
## GC算法
+ 标记-清除算法（Mark-Swap）
>1 标记所有存活的对象
>2  标记完成后统一回收掉所有未被标记的对象
>效率不高，需要扫描所有的对象。并且存在内存碎片问题。

+ 复制算法（Copying）
> 1 将内存等分2块 每次只使用一块
> 2 当这一块的内存用完了，就将还存活着的对象复制到另外一块上面
> 3 然后再把已使用过的内存空间一次清理掉
>  只需要扫描存活的对象（只要有依赖），效率变高。
>不会产生内存碎片
>缺点在于利用空间换时间

+ 标记-整理算法（Mark-Compact）
>1 标记所有存活的对象
>2  将存活的对象向前移动进行排序
>3  移动完成后统一回收掉末端的对象
> 优化了内存碎片问题，但是耗时更多。
> 复制收集算法在对象存活率较高时就要执行较多的复制操作，效率将会变低。更关键的是，如果不想浪费50%的空间，就需要有额外的空间进行分配担保，以应对被使用的内存中所有对象都100%存活的极端情况，所以在老年代一般不能直接选用这种算法。

+ 分带算法（Generational）
> 根据不同生命周期的对象采用不同的GC算法