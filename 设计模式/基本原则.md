#开闭原则(OCP)
> 设计的 软件/类/方法 针对拓展开放.针对修改关闭  而不是修改现有的代码
> 开闭原则是设计模式的基本原则 其他大多数原则都基本遵循开闭原则

#单一职责原则
>**规定:** 一个类应该只有一个发生变化的原因
> 设计的 软件/类/方法 只处理一件事情
+ 降低类的复杂度；
+ 提高类的可读性，提高系统的可维护性；
+ 降低变更引起的风险（降低对其他功能的影响）。

#接口隔离原则
> 客户端不应该依赖它不需要的接口
>一个类对另一个类的依赖应该建立在最小的接口上；
>一个接口代表一个角色，不应该将不同的角色都交给一个接口，因为这样可能会形成一个臃肿的大接口；
>不应该强迫客户依赖它们从来不用的方法。

#依赖倒置原则(DIP)
##概念
+  **低层模块：**不可分割的原子逻辑，可能会根据业务逻辑经常变化。*(被调用者)*
+ **高层模块：**低层模块的再组合，对低层模块的抽象。*(调用者)*
+ **抽象：** 接口或抽象类（是底层模块的抽象，特点：不能直接被实例化）
+ **与接口或抽象类对应的实现类：**低层模块的具体实现（特点：可以直拉被实例化）
**example:** `controler`>`service`>`dao` 层次模块从高到低

##原则
+ 任何变量, 类都不应该有一个指向具体类的指针或者引用
+ 任何类都不该从具体类派生
+ 任何方法都不该覆写它的任何基类中已经实现了的方法
<br/>
<br/>
1. 模块间的依赖通过抽象发生，实现类之间不发生直接的依赖关系，其依赖关系是通过接口或抽象类产生的
2. 接口或抽象类不依赖于实现类
3. 实现类依赖于接口或抽象类

> 抽象不应该依赖细节, 细节应当依赖于抽象 *针对接口/抽象 编程,不是针对细节*
> 高模块尽量不去依赖低模块的细节 , 而是依赖底层模块的抽象/接口
> 在java中，依赖表现为：局部变量，方法中的参数和对静态方法的调用。
##解决问题
+ 上层应用调用下层应用  下层应用 变化会导致上层应用不稳定


#迪米特法则(最少知道原则)
>一个对象应该对其他对象保持最少的了解。
> 如果两个类不必彼此直接通信，那么这两个类就不应当发生直接的相互作用。如果其中一个类需要调用另一类的某一个方法的话，可以通过第三者转发这个调用。
> 关系包括 组合/关联/依赖/等等
> >需要程序员自己约束不合理的类之间的依赖关系
> 
#里式替换原则
>所有引用基类的地方必须能透明地使用其子类的对象。
解决：当使用继承时，遵循里氏替换原则。类B继承类A时，除添加新的方法完成新增功能P2外，尽量不要重写父类A的`非抽象`方法，
     也尽量不要重载父类A的`非抽象`方法
> 若必须`重写``出参`必须必父类`更严格`, `入参`一致
> >若必须`重载``入参`必须必父类`更宽容`